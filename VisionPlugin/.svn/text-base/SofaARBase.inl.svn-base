/******************************************************************************
*       SOFA, Simulation Open-Framework Architecture, version 1.0 RC 1        *
*                (c) 2006-2011 MGH, INRIA, USTL, UJF, CNRS                    *
*                                                                             *
* This library is free software; you can redistribute it and/or modify it     *
* under the terms of the GNU Lesser General Public License as published by    *
* the Free Software Foundation; either version 2.1 of the License, or (at     *
* your option) any later version.                                             *
*                                                                             *
* This library is distributed in the hope that it will be useful, but WITHOUT *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License *
* for more details.                                                           *
*                                                                             *
* You should have received a copy of the GNU Lesser General Public License    *
* along with this library; if not, write to the Free Software Foundation,     *
* Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.          *
*******************************************************************************
*                               SOFA :: Plugins                               *
*                                                                             *
* Authors: The SOFA Team and external contributors (see Authors.txt)          *
*                                                                             *
* Contact information: contact@sofa-framework.org                             *
******************************************************************************/
/*
 * SofaARBase.cpp
 *
 *  Created on: 29 may 2012
 *      Author: Nazim HAOUCHINE
 */

#include "SofaARBase.h"
#include "SofaARCapsule.h"
#include <sofa/core/ObjectFactory.h>
#include <sofa/helper/accessor.h>

#define HOST "127.0.0.1"
#define PORT "8888"

using boost::asio::ip::tcp;

std::string imgData;
int imageWidth;
int imageHeight;
int flagReceived = 0;
int flag1stPassage = 1;
std::vector<float> currentPositionsX, currentPositionsY, currentPositionsZ;


namespace sofa{
  namespace component{
    namespace visualmodel{

	//constructeur
	template <class DataTypes>
	SofaARBase<DataTypes>::SofaARBase()
		:
		m_currentPositions( initData (&m_currentPositions, "currentPositions", "Current position of the Control Point"))
	{

	}

	//destructeur
	template <class DataTypes>
	SofaARBase<DataTypes>::~SofaARBase()
	{
	}

	template <class DataTypes>
	void SofaARBase<DataTypes>::init()
	{
		std::cout << "Sofa is a TCP Client and is now running.."<< std::endl;
	}

	template <class DataTypes>
	void SofaARBase<DataTypes>::draw()
	{
	
		// TCP Client     
		try
	    	{	
			// stream connection
			tcp::iostream data_stream("127.0.0.1", PORT);

			// receiving
			SofaARCapsule cap_recv;
			boost::archive::binary_iarchive ia(data_stream);
			ia >> cap_recv; // unserialization
			imgData = cap_recv.getImg();			// buffer image	
			imageWidth = cap_recv.getImgWidth();		// image width
			imageHeight = cap_recv.getImgHeight();		// image height	
			currentPositionsX = cap_recv.getCurrentPositionX(); // current positions
           		currentPositionsY = cap_recv.getCurrentPositionY(); // current positions
           		currentPositionsZ = cap_recv.getCurrentPositionZ(); // current positions

			// sending back
			// Example of a process on the received data
			// the current positions received from server are
			// sent back after the incrementation of the first element of a vector...
			currentPositionsX.at(0) = 99.99;
			
            SofaARCapsule cap_sent(cap_recv.getImg(), cap_recv.getImgDepth(), cap_recv.getImgNC(), cap_recv.getImgWidth(), cap_recv.getImgHeight(), currentPositionsX, currentPositionsY, currentPositionsZ);
			
			boost::archive::binary_oarchive oa(data_stream);
			oa << cap_sent; // serialization

			// stream closing
			data_stream.close();

			std::cout << "Client <<< Server :\t"<< sizeof(cap_recv) << std::endl;
			std::cout << "Client >>> Server :\t" << sizeof(cap_sent) << std::endl;
			// member accessor
			helper::WriteAccessor<Data<VecCoord> > writeCurrentPositions = m_currentPositions;
			
			// resize the vector with the number of initial control point
			if (!flagReceived) { 
				writeCurrentPositions.resize(currentPositionsX.size());	
				std::cout << "Current Positions Vector resized to : " << currentPositionsX.size() << std::endl;
			}

			// used for resizing vectors and to prevent from opengl empty buffer
			flagReceived = 1;
			
			// update the positions
			// since Boost::asio only support basic vector (ie : vector<float>, vector<int> ...)
			// we define a vector for each coordinate x,y,z.
			for (int i = 0; i < currentPositionsX.size(); i++) {		
				writeCurrentPositions[i] = Coord(
						currentPositionsX.at(i), 
                        currentPositionsY.at(i),
                        currentPositionsZ.at(i)
					);

			}
		}
	   	catch (std::exception& e)
	   	{
			//std::cerr << e.what() << std::endl;
	   	}// end of TCP client

	if(flagReceived)
	{
		/*
		helper::ReadAccessor<Data<VecCoord> > readCurrentPosition = m_currentPositions;
		for (int i = 0 ; i < (int)readCurrentPosition.size() ; i++)	
			std::cout << i << " :\t" << readCurrentPosition[i] << std::endl;	
		*/
		
		//std::cout << "Drawing the background.." << std::endl;

		// TRANSPARANCY
		//glEnable(GL_BLEND) ;
		//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) ;

		// VIEW
		glMatrixMode(GL_PROJECTION);	//init the projection matrix
		glPushMatrix();
		glLoadIdentity();	// reset the view
		glOrtho(0,1,0,1,-1,1);  // orthogonal view		
		glMatrixMode(GL_MODELVIEW);  
		glPushMatrix(); 
		glLoadIdentity(); 

		//glEnable(GL_POLYGON_OFFSET_LINE) ;
		//glDisable(GL_DEPTH_TEST);

		// BACKGROUND TEXTURING
		glDepthMask (GL_FALSE);		// disable the writing of zBuffer
		glEnable(GL_TEXTURE_2D);	// enable the texture	
		glDisable(GL_LIGHTING);		// disable the light
		        	
		glBindTexture ( GL_TEXTURE_2D, 0 );  // texture bind	
		glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, imageWidth, imageHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, imgData.c_str() ); 	

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);	// Linear Filtering
		 
		// BACKGROUND DRAWING		 
		//glEnable(GL_DEPTH_TEST);		
	
		glBegin(GL_QUADS); //we draw a quad on the entire screen (0,0 1,0 1,1 0,1)  
			glColor4f(1.0f,1.0f,1.0f,1.0f); 
			glTexCoord2f(0,1);		glVertex2f(0,0);
			glTexCoord2f(1,1);		glVertex2f(1,0);
			glTexCoord2f(1,0);		glVertex2f(1,1);
			glTexCoord2f(0,0);		glVertex2f(0,1);
		glEnd();             

		//glEnable(GL_DEPTH_TEST);
		glEnable(GL_LIGHTING);		// enable light
		glDisable(GL_TEXTURE_2D);	// disable texture 2D	
		glDepthMask (GL_TRUE);		// enable zBuffer
			        
		glPopMatrix();
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();
		glMatrixMode(GL_MODELVIEW);    
	}
	else std::cout <<  "Waiting for data from Server ... " << std::endl;
	

	}
	
  }
 }
}
