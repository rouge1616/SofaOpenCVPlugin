/******************************************************************************
*       SOFA, Simulation Open-Framework Architecture, version 1.0 RC 1        *
*                (c) 2006-2011 MGH, INRIA, USTL, UJF, CNRS                    *
*                                                                             *
* This library is free software; you can redistribute it and/or modify it     *
* under the terms of the GNU Lesser General Public License as published by    *
* the Free Software Foundation; either version 2.1 of the License, or (at     *
* your option) any later version.                                             *
*                                                                             *
* This library is distributed in the hope that it will be useful, but WITHOUT *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License *
* for more details.                                                           *
*                                                                             *
* You should have received a copy of the GNU Lesser General Public License    *
* along with this library; if not, write to the Free Software Foundation,     *
* Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.          *
*******************************************************************************
*                               SOFA :: Modules                               *
*                                                                             *
* Authors: The SOFA Team and external contributors (see Authors.txt)          *
*                                                                             *
* Contact information: contact@sofa-framework.org                             *
******************************************************************************/
#include <ProjectivePattern.h>
#include <sofa/core/visual/DrawToolGL.h>
#include <sofa/simulation/common/Node.h>
#include <sofa/component/visualmodel/OglModel.h>
#include <sofa/component/topology/TopologyData.inl>
#include <sofa/core/visual/VisualParams.h>
#include <sofa/helper/system/gl.h>
#include <sofa/helper/system/glut.h>
#include <sofa/helper/gl/RAII.h>
#include <sofa/helper/vector.h>
#include <sofa/defaulttype/Quat.h>
#include <sofa/core/ObjectFactory.h>
#include <sofa/core/topology/BaseMeshTopology.h>
#include <sstream>
#include <string.h>
#include <iostream>
#include <fstream>


//#define NO_VBO

namespace sofa
{

namespace component
{

namespace visualmodel
{

const double NOISE_THRESHOLD = 0.8;

using namespace sofa::defaulttype;
using namespace sofa::core::loader;

SOFA_DECL_CLASS(ProjectivePattern)

int ProjectivePatternClass = core::RegisterObject("Projective Pattern Class - WIP")
.add< ProjectivePattern >()
;

template<class T>
const T* getData(const defaulttype::ResizableExtVector<T>& v) { return v.getData(); }

template<class T>
const T* getData(const sofa::helper::vector<T>& v) { return &v[0]; }


ProjectivePattern::ProjectivePattern() : 
            useProceduralSampling(initData(&useProceduralSampling, true, "useProceduralSampling", "useProceduralSampling (Noise or Grid samplings)")),
            useRegularSampling(initData(&useRegularSampling, true, "useRegularSampling", "regular sampling vs gaussian distrib")),
            updateEveryTimestep(initData(&updateEveryTimestep, false, "updateEveryTimestep", "updateEveryTimestep (or once at creation)")),
            origin(initData(&origin, "origin", "Origin of the source")),
            radius(initData(&radius, "radius", "radius of the source")),
	    projectionShift(initData(&projectionShift, "projectionShift", "Shift the projected pattern")),
            samples(initData(&samples, "samples", "number of rays")),                   
            quaternion(initData(&quaternion, "quaternion", "quaternion representing from orientation")),
            noiseSeed(initData(&noiseSeed, "noiseSeed", "seed for noise generation")),
            drawingSize(initData(&drawingSize, "drawingSize", "size for drawing sphere and origin arrow (Arrow Radius, Arrow Lenght, Sphere Radius)")),
            trackedPoints(initData(&trackedPoints, "trackedPoints", "vector of tracked points")),
	    omVertices(initData(&omVertices, "omVertices", "vector of visual model vertices")),
	    omNormals(initData(&omNormals, "omNormals", "vector of visual model normals")),
	    projectedPoints(initData(&projectedPoints, "projectedPoints", "vector of projected points"))
{

}

ProjectivePattern::~ProjectivePattern()
{
    m_fileLog.close();

}

double ProjectivePattern::euclideanDistance( Vec3d pt1, Vec3d pt2 ) const 
{
	return sqrt((pt1[0] - pt2[0])*(pt1[0] - pt2[0]) + (pt1[1] - pt2[1])*(pt1[1] - pt2[1]) + (pt1[2] - pt2[2])*(pt1[2] - pt2[2]) );
}

double ProjectivePattern::computeLeastSquares(helper::ReadAccessor<Data<VecCoord> > trueValues, ResizableExtVector<Coord> etimatedValues)
{
	double S = 0.0;
	int n = etimatedValues.size(); 
	if (etimatedValues.size() == trueValues.size())
	{	
		for(int i=0 ; i<n ; i++)
		{
			if(projected_points_status[i]) {
				double ri = euclideanDistance(etimatedValues[i],trueValues[i]);
				S+= ri*ri;
			}
		}
	}
	return S;
}

double ProjectivePattern::computeLeastMeanSquares(helper::ReadAccessor<Data<VecCoord> > trueValues, ResizableExtVector<Coord> etimatedValues)
{
	double S = 0.0;
	int n = etimatedValues.size(); 
	if (etimatedValues.size() == trueValues.size())
	{	
		for(int i=0 ; i<n ; i++)
		{
			if(projected_points_status[i]) {
				double ri = euclideanDistance(etimatedValues[i],trueValues[i]);
				S+= ri*ri;
			}
		}
	}
	return S/n;
}

double ProjectivePattern::computeRootMeanSquares(helper::ReadAccessor<Data<VecCoord> > trueValues, ResizableExtVector<Coord> etimatedValues)
{
	double S = 0.0;
	int n = etimatedValues.size(); 
	if (etimatedValues.size() == trueValues.size())
	{	
		for(int i=0 ; i<n ; i++)
		{
			if(projected_points_status[i]) {
				double ri = euclideanDistance(etimatedValues[i],trueValues[i]);
				S+= ri*ri/n;
			}
		}
	}

	return sqrt(S);
}

void ProjectivePattern::initVisual()
{
    m_fileLog.open("applications-dev/plugins/SofaAR/example/projected.obj");

    _refModel = this->getContext()->get<component::visualmodel::OglModel>();
    _refTrackedModel = this->getContext()->get< core::behavior::MechanicalState<Vec3dTypes> >();
    
    if(!_refModel)
        serr << "No Ref Model found ! Component creation will fail" << std::endl;

    if(!useProceduralSampling.getValue() && !_refTrackedModel)
        serr << "MechanicalObject is required if not using procedural sampling ! Component creation will fail" << std::endl;

    if(_refModel->isUseTriangles())
    {
	triangles = _refModel->getTriangles();
    }
    if(_refModel->isUseQuads())
    {
	quads = _refModel->getQuads();
    }

    verti = _refModel->getVertices();
    norma = _refModel->getVnormals();
    
    computeSampling();

    helper::WriteAccessor<Data<ResizableExtVector<Coord> > > pp = projectedPoints;
    
    pp.resize(projected_points.size());
    for( int i = 0; i < projected_points.size(); i++) {
	pp[i] = projected_points[i];
	m_fileLog << "v " << projected_points[i][0] << " " << projected_points[i][1] << " " << projected_points[i][2] << std::endl; 
    }

}

void ProjectivePattern::computeSampling()
{
    projected_points.clear();
    const Vec3d myDir(0, 0, -1);
    const Vec3d dirOriented = quaternion.getValue().rotate(myDir);

    helper::ReadAccessor<Data<ResizableExtVector<Coord> > > vertices = omVertices;
    helper::ReadAccessor<Data<ResizableExtVector<Coord> > > normals = omNormals;

    if(_refModel->isUseTriangles())
    {
        for(unsigned int k = 0; k < triangles.size(); k++)
        {
            Triangle tri= triangles[k];

            Vec3d normal = normals[tri[0]];
            normal += normals[tri[1]];
            normal += normals[tri[2]];


            if( dot(normal, dirOriented) < 0.0) // triangle has a good orientation w/ respect to direction of rays
            {

                if(!useProceduralSampling.getValue()) {
                    computePointCloudSampling(dirOriented, vertices[tri[0]], vertices[tri[1]], vertices[tri[2]]);
 
		}
                else if(useRegularSampling.getValue())
                    computeRegularSampling(dirOriented, vertices[tri[0]], vertices[tri[1]], vertices[tri[2]]);
                else
                    computeNoiseSampling(dirOriented, vertices[tri[0]], vertices[tri[1]], vertices[tri[2]]);
            }
        }
    }

    if(_refModel->isUseQuads())
    {
        for(unsigned int k = 0; k < quads.size(); k++)
        {
            Quad q = quads[k];

            Vec3d normal1 = normals[q[0]];
            normal1 += normals[q[1]];
            normal1 += normals[q[2]];

	    Vec3d normal2 = normals[q[0]];
            normal2 += normals[q[2]];
            normal2 += normals[q[3]];

            if( dot(normal1, dirOriented) < 0.0) // quad has a good orientation w/ respect to direction of rays
            {
                if(!useProceduralSampling.getValue()) {
                    computePointCloudSampling(dirOriented, vertices[q[0]], vertices[q[1]], vertices[q[2]]);
		}
                else if(useRegularSampling.getValue())
                    computeRegularSampling(dirOriented, vertices[q[0]], vertices[q[1]], vertices[q[2]]);
                else
                    computeNoiseSampling(dirOriented, vertices[q[0]], vertices[q[1]], vertices[q[2]]);
            }

            if( dot(normal2, dirOriented) < 0.0) // quad has a good orientation w/ respect to direction of rays
            {
		if(!useProceduralSampling.getValue()) {
                    computePointCloudSampling(dirOriented, vertices[q[0]], vertices[q[2]], vertices[q[3]]);
		}
                else if(useRegularSampling.getValue())
                    computeRegularSampling(dirOriented, vertices[q[0]], vertices[q[2]], vertices[q[3]]);
                else
                    computeNoiseSampling(dirOriented, vertices[q[0]], vertices[q[2]], vertices[q[3]]);
            }
        }
    }
}

void ProjectivePattern::computePointCloudSampling(const Vec3d &dir, Coord p1, Coord p2, Coord p3)
{

    // const Vec3dTypes::VecCoord * vert = _refTrackedModel->getX();
    helper::ReadAccessor<Data<VecCoord> > tPoints = trackedPoints;

    projected_points.resize(tPoints.size());
    projected_points_status.resize(projected_points.size());

    Vec3d curVec;
    double t,u,v;
    Vec3d shiftVec = projectionShift.getValue();

    for( int i = 0 ; i < tPoints.size() ; i++ )
    {
        curVec = (tPoints)[i];
	       curVec[0] += shiftVec[0]; // x translation to avoid to have the projected point on the obj surface
	       curVec[1] += shiftVec[1]; // y translation to avoid to have the projected point on the obj surface	
	       curVec[2] += shiftVec[2]; // z translation to avoid to have the projected point on the obj surface

        if (rayCaster.NewComputation(
                p1, p2, p3,
                curVec, 
                dir, 
                t, u , v) )
        {
            Vec3d inter = curVec + dir * t;
            projected_points[i] = Coord(inter);
            projected_points_status[i] = 1;
	}

    }
}

void ProjectivePattern::computeRegularSampling(const Vec3d &dir, Coord p1, Coord p2, Coord p3)
{    
    int dimSamples = sqrt(samples.getValue());
    float incr = 2.0 * radius.getValue() / (dimSamples - 1);
    Vec3d curVec;
    
    double t,u,v;
    Real rad = radius.getValue();
    Vec3d orig = origin.getValue();

    for(int i = 0; i < dimSamples; i++)
    {
        for(int j = 0; j < dimSamples; j++)
        {
            curVec.set(- rad + i * incr, - rad + j * incr, 0);
            curVec = quaternion.getValue().rotate(curVec);
            curVec += orig;

            //std::cout << curVec << std::endl;

            if (rayCaster.NewComputation(
                    p1, p2, p3,
                    curVec, 
                    dir, 
                    t, u , v) )
            {

                Vec3d inter = curVec + dir * t;

                projected_points.push_back(inter);
            }
        }
    }
    //std::cout << std::endl;
}

void ProjectivePattern::computeNoiseSampling(const Vec3d &dir, Coord p1, Coord p2, Coord p3)
{
    Vec3d curVec;

    srand(noiseSeed.getValue());

    double t,u,v; 
    double x,y;
    Real rad = radius.getValue();
    Vec3d orig = origin.getValue();

    for (int i = 0; i < samples.getValue(); ++i)
    {
        x = (double) (2.0 * rand() / RAND_MAX); 
        y = (double) (2.0 * rand() / RAND_MAX);

        curVec.set(- rad + x * rad, - rad + y * rad, 0);
        curVec = quaternion.getValue().rotate(curVec);
        curVec += orig;

        if (rayCaster.NewComputation(
                p1, p2, p3,
                curVec, 
                dir, 
                t, u , v) )
        {

            Vec3d inter = curVec + dir * t;
            projected_points.push_back(Coord(inter));
        }
    }
}

void ProjectivePattern::updateBuffers()
{  
    // VisualModelImpl::updateBuffers();
}

void ProjectivePattern::draw()
{    
    Vec3d orig = origin.getValue();
    const Vec3d myDir(0, 0, -1);
    const Vec3d dirOriented = quaternion.getValue().rotate(myDir);
    Vec3d dsize = drawingSize.getValue();

    drawable.draw(origin.getValue(), orig + dirOriented * dsize[1], dsize[0]);

    if(updateEveryTimestep.getValue())
        computeSampling();
/*
    for( int i = 0; i < projected_points.size(); i++)
    {
	//std::cout << "v " << projected_points[i][0] << " " << projected_points[i][1] << " " << projected_points[i][2] << std::endl; 
	//m_fileLog << "v " << projected_points[i][0] << " " << projected_points[i][1] << " " << projected_points[i][2] << std::endl; 
	//gl::Color::setHSVA(0.5, 0.5, 0.7, 1.0);
	//glColor3f(1.0, 0.0, 0.0);
        //gl::drawSphere(projected_points[i], dsize[2]);
    }
*/
//    std::cout << "once" << std::endl;

//    std::cout << "--------------------------------\n"<< std::endl;
/*
    const Vec3dTypes::VecCoord * vert = _refTrackedModel->getX();
    for( int i = 0; i < vert->size(); i++)
    {
        std::cout << (*vert)[i] << std::endl;
	
	Vec3d curVec = (*vert)[i];
	curVec[0] +=100;
	curVec[1] +=100;
	curVec[2] +=100;
        gl::drawSphere( (*vert)[i], dsize[2]);
	
    }
*/

}

} // namespace visualmodel

} // namespace component

} // namespace sofa

